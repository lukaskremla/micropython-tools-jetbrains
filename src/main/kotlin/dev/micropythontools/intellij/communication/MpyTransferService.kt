/*
 * Copyright 2000-2024 JetBrains s.r.o.
 * Copyright 2024-2025 Lukas Kremla
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.micropythontools.intellij.communication

import com.intellij.notification.Notification
import com.intellij.notification.NotificationType
import com.intellij.notification.Notifications
import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.fileEditor.FileDocumentManager
import com.intellij.openapi.fileTypes.FileTypeRegistry
import com.intellij.openapi.progress.checkCanceled
import com.intellij.openapi.project.Project
import com.intellij.openapi.project.guessProjectDir
import com.intellij.openapi.project.modules
import com.intellij.openapi.project.rootManager
import com.intellij.openapi.vfs.VfsUtil
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.project.stateStore
import com.jetbrains.python.sdk.PythonSdkUtil
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.withTimeout
import ui.NOTIFICATION_GROUP
import ui.fileSystemWidget
import ui.performReplAction
import util.MpyPythonService
import java.io.IOException

@Service(Service.Level.PROJECT)
class MpyTransferService {
    companion object {
        fun getInstance(project: Project): MpyTransferService =
            project.getService(MpyTransferService::class.java)
    }

    private fun VirtualFile.leadingDot() = this.name.startsWith(".")

    private fun collectProjectUploadables(project: Project): Set<VirtualFile> {
        return project.modules.flatMap { module ->
            module.rootManager.contentEntries
                .mapNotNull { it.file }
                .flatMap { it.children.toList() }
                .filter { !it.leadingDot() }
                .toMutableList()
        }.toSet()
    }

    private fun collectExcluded(project: Project): Set<VirtualFile> {
        val ideaDir = project.stateStore.directoryStorePath?.let { VfsUtil.findFile(it, false) }
        val excludes = if (ideaDir == null) mutableSetOf() else mutableSetOf(ideaDir)
        project.modules.forEach { module ->
            PythonSdkUtil.findPythonSdk(module)?.homeDirectory?.apply { excludes.add(this) }
            module.rootManager.contentEntries.forEach { entry ->
                excludes.addAll(entry.excludeFolderFiles)
            }
        }
        return excludes
    }

    private fun collectSourceRoots(project: Project): Set<VirtualFile> {
        return project.modules.flatMap { module ->
            module.rootManager.contentEntries
                .flatMap { entry -> entry.sourceFolders.toList() }
                .filter { sourceFolder ->
                    !sourceFolder.isTestSource && sourceFolder.file?.let { !it.leadingDot() } ?: false
                }
                .mapNotNull { it.file }
        }.toSet()
    }

    private fun collectTestRoots(project: Project): Set<VirtualFile> {
        return project.modules.flatMap { module ->
            module.rootManager.contentEntries
                .flatMap { entry -> entry.sourceFolders.toList() }
                .filter { sourceFolder -> sourceFolder.isTestSource }
                .mapNotNull { it.file }
        }.toSet()
    }

    fun uploadProject(
        project: Project,
        excludedPaths: List<String> = emptyList(),
        shouldSynchronize: Boolean = false,
        shouldExcludePaths: Boolean = false,
        useFTP: Boolean = false,
        ssid: String = "",
        wifiPassword: String = ""
    ): Boolean {

        FileDocumentManager.getInstance().saveAllDocuments()
        val filesToUpload = collectProjectUploadables(project)
        return performUpload(
            project,
            filesToUpload,
            true,
            excludedPaths,
            shouldSynchronize,
            shouldExcludePaths,
            useFTP,
            ssid,
            wifiPassword
        )
    }

    fun uploadFileOrFolder(
        project: Project,
        toUpload: VirtualFile,
        excludedPaths: List<String> = emptyList(),
        shouldSynchronize: Boolean = false,
        shouldExcludePaths: Boolean = false,
        useFTP: Boolean = false,
        ssid: String = "",
        wifiPassword: String = ""
    ): Boolean {

        FileDocumentManager.getInstance().saveAllDocuments()
        return performUpload(
            project,
            setOf(toUpload),
            false,
            excludedPaths,
            shouldSynchronize,
            shouldExcludePaths,
            useFTP,
            ssid,
            wifiPassword
        )
    }

    fun uploadItems(
        project: Project,
        toUpload: Set<VirtualFile>,
        excludedPaths: List<String> = emptyList(),
        shouldSynchronize: Boolean = false,
        shouldExcludePaths: Boolean = false,
        useFTP: Boolean = false,
        ssid: String = "",
        wifiPassword: String = ""
    ): Boolean {

        FileDocumentManager.getInstance().saveAllDocuments()
        return performUpload(
            project,
            toUpload,
            false,
            excludedPaths,
            shouldSynchronize,
            shouldExcludePaths,
            useFTP,
            ssid,
            wifiPassword
        )
    }

    private fun performUpload(
        project: Project,
        toUpload: Set<VirtualFile>,
        initialIsProjectUpload: Boolean,
        excludedPaths: List<String> = emptyList(),
        shouldSynchronize: Boolean = false,
        shouldExcludePaths: Boolean = false,
        useFTP: Boolean = false,
        ssid: String = "",
        password: String = ""
    ): Boolean {

        val pythonService = project.service<MpyPythonService>()

        var isProjectUpload = initialIsProjectUpload
        var filesToUpload = toUpload.toMutableList()
        val excludedFolders = collectExcluded(project)
        val sourceFolders = collectSourceRoots(project)
        val testFolders = collectTestRoots(project)
        val projectDir = project.guessProjectDir()

        var ftpUploadClient: MpyFTPClient? = null
        var uploadedSuccessfully = false

        performReplAction(
            project = project,
            connectionRequired = true,
            description = "Upload",
            requiresRefreshAfter = true,
            action = { fileSystemWidget, reporter ->
                reporter.text("Collecting files to upload...")
                reporter.fraction(null)

                var i = 0
                while (i < filesToUpload.size) {
                    val file = filesToUpload[i]

                    val shouldSkip = !file.isValid ||
                            (file.leadingDot() && file != projectDir) ||
                            FileTypeRegistry.getInstance().isFileIgnored(file) ||
                            excludedFolders.any { VfsUtil.isAncestor(it, file, true) } ||
                            (isProjectUpload && testFolders.any { VfsUtil.isAncestor(it, file, true) }) ||
                            (isProjectUpload && sourceFolders.isNotEmpty() &&
                                    !sourceFolders.any { VfsUtil.isAncestor(it, file, false) })

                    when {
                        shouldSkip -> {
                            filesToUpload.removeAt(i)
                        }

                        file == projectDir -> {
                            i = 0
                            filesToUpload.clear()
                            filesToUpload = collectProjectUploadables(project).toMutableList()
                            isProjectUpload = true
                        }

                        file.isDirectory -> {
                            filesToUpload.addAll(file.children)
                            filesToUpload.removeAt(i)
                        }

                        else -> i++
                    }

                    checkCanceled()
                }
                val uniqueFilesToUpload = filesToUpload.distinct()
                val fileToTargetPath = mutableMapOf<VirtualFile, String>()

                uniqueFilesToUpload.forEach { file ->
                    val path = when {
                        sourceFolders.find { VfsUtil.isAncestor(it, file, false) }?.let { sourceRoot ->
                            VfsUtil.getRelativePath(file, sourceRoot) ?: file.name
                        } != null -> VfsUtil.getRelativePath(
                            file,
                            sourceFolders.find { VfsUtil.isAncestor(it, file, false) }!!
                        ) ?: file.name

                        else -> projectDir?.let { VfsUtil.getRelativePath(file, it) } ?: file.name
                    }

                    fileToTargetPath[file] = if (path.startsWith("/")) path else "/$path"
                }

                val scriptProgressText = if (shouldSynchronize) {
                    "Syncing and skipping already uploaded files..."
                } else {
                    "Detecting already uploaded files..."
                }

                reporter.text(scriptProgressText)
                reporter.fraction(null)

                val alreadyUploadedFiles = fileSystemWidget.synchronizeAndGetAlreadyUploadedFiles(
                    fileToTargetPath,
                    excludedPaths,
                    shouldSynchronize,
                    shouldExcludePaths
                )
                fileToTargetPath.keys.removeAll(alreadyUploadedFiles.toSet())

                if (useFTP && fileToTargetPath.isNotEmpty()) {
                    if (ssid.isEmpty()) {
                        Notifications.Bus.notify(
                            Notification(
                                NOTIFICATION_GROUP,
                                "Cannot upload over FTP, no SSID was provided in settings! Falling back to normal communication.",
                                NotificationType.ERROR
                            ), project
                        )
                    } else {
                        reporter.text("Establishing an FTP server connection...")
                        reporter.fraction(null)

                        val scriptFileName = "ftp.py"

                        val ftpScript = pythonService.retrieveMpyScriptAsString(scriptFileName)

                        val formattedScript = ftpScript.format(
                            """"$ssid"""",
                            """"$password"""",
                            20 // Wi-Fi connection timeout
                        )

                        val scriptResponse = fileSystemWidget.blindExecute(LONG_TIMEOUT, formattedScript)
                            .extractSingleResponse().trim()

                        if (scriptResponse.contains("ERROR") || !scriptResponse.startsWith("IP: ")) {
                            Notifications.Bus.notify(
                                Notification(
                                    NOTIFICATION_GROUP,
                                    "Ran into an error establishing an FTP connection, falling back to normal communication: $scriptResponse",
                                    NotificationType.ERROR
                                ), project
                            )
                        } else {
                            try {
                                val ip = scriptResponse.removePrefix("IP: ")

                                ftpUploadClient = MpyFTPClient()
                                ftpUploadClient?.connect(ip, "", "") // No credentials are used
                            } catch (e: Exception) {
                                Notifications.Bus.notify(
                                    Notification(
                                        NOTIFICATION_GROUP,
                                        "Connecting to FTP server failed: $e",
                                        NotificationType.ERROR
                                    ), project
                                )
                            }
                        }
                    }
                }

                val totalBytes = fileToTargetPath.keys.sumOf { it.length }

                var uploadProgress = 0.0
                var uploadedKB = 0.0
                var uploadedFiles = 1

                fun progressCallbackHandler(uploadedBytes: Int) {
                    uploadedKB += (uploadedBytes.toDouble() / 1000)
                    // Convert to double for maximal accuracy
                    uploadProgress += (uploadedBytes.toDouble() / totalBytes.toDouble())
                    // Ensure that uploadProgress never goes over 1.0
                    // as floating point arithmetic can have minor inaccuracies
                    uploadProgress = uploadProgress.coerceIn(0.0, 1.0)
                    reporter.text("Uploading: file $uploadedFiles of ${fileToTargetPath.size} | ${"%.2f".format(uploadedKB)} KB of ${totalBytes / 1000} KB")
                    reporter.fraction(uploadProgress)
                }

                fileToTargetPath.forEach { (file, path) ->
                    reporter.details(path)

                    if (ftpUploadClient != null) {
                        try {
                            withTimeout(10_000) {
                                ftpUploadClient?.uploadFile(path, file.contentsToByteArray(), ::progressCallbackHandler)
                            }
                        } catch (e: TimeoutCancellationException) {
                            throw IOException("Timed out while uploading a file with FTP")
                        }
                    } else {
                        fileSystemWidget.upload(path, file.contentsToByteArray(), ::progressCallbackHandler)
                    }

                    uploadedFiles++
                    checkCanceled()
                }

                // reporter text and fraction parameters are always set when the reporter is used elsewhere,
                // but details aren't thus they should be cleaned up
                reporter.details(null)

                uploadedSuccessfully = true
            },

            cleanUpAction = { fileSystemWidget, reporter ->
                if (fileSystemWidget.state == State.CONNECTED) {
                    ftpUploadClient?.disconnect()

                    reporter.text("Cleaning up after FTP upload...")
                    reporter.fraction(null)

                    if (useFTP) {
                        val scriptFileName = "ftp_cleanup.py"

                        val ftpCleanupScript = pythonService.retrieveMpyScriptAsString(scriptFileName)

                        fileSystemWidget(project)?.blindExecute(TIMEOUT, ftpCleanupScript)
                    }
                }
            }
        )
        return uploadedSuccessfully
    }
}